- 注意，用于接受字符串的字符数组定义时的数组长度应足够长，以便保存整个字符串和字符串结束标志。否则，函数将把超过字符数组定义的长度之外的字符顺序保存在数组范围之外的内存单元中，从而可能覆盖其他变量的内容，造成程序出错。 

- 简而言之，C语言中字符数组和字符指针都可以表示字符串，但是二者存在本质区别，前者是连续内存，直接申请存放字符串的内存空间；后者是地址，只申请了存放字符串起始地址的空间，需要通过其他方式申请存放字符串的空间。实际使用时，形参常用字符指针形式，其他位置常用字符数组。 

- 主函数中采用字符数组而不是字符指针形式来代表字符串，这样做的好处是可以在主函数中省掉了动态申请串的存储空间语句。 

- 二维数组存储空间固定，字符指针数组相当于可变列长的二维数组。 

- 注意：枚举常量是被命名的整数常量，不是变量。枚举常量只能作为整数直接输入输出，不能作为串直接输入输出。 

- 结构类型的存储空间等于或大于成员长度之和。 

- 如果main（）在一个递归程序中，exit（）仍然会终止程序，但是return只会把控制权交给上一级递归，直至最初的一级。然后return结束程序。return和exit（）的另一个区别是，即使在其他函数中（除main（）以外）调用exit（）也能结束整个程序。 

- 以二进制表示法储存数据的缺点是，不同的系统可能使用不同的二进制表示法，所以数据文件可能不具有可移植性。甚至同一个系统，不同编译器设置也可能导致不同的二进制布局。 

- 一般而言，不要在宏中使用递增或递减运算符。 

- 用空指针作实参调用fflush（）函数时，所有用于输出模式的文件都被清仓。 

- 总之，指针或地址是没有必要存入到文件中的，即便存入到文件中，以后也绝不能使用这些地址类别数据，否则将可能引发严重错误。 

- 请注意，文件名是帮助操作系统识别数据用的，而流名称则是程序中使用的，二者有着根本的区别。 

  ```c
  union values
  {
      char w;
      float x;
      double y; 
  }v={1.28}
  ```

  答：错误，联合类型变量只能用与其第一个成员相同数据类型的数值来初始化。 

- 从文件paytable.dat中读入一条记录（所有输入项account和amount都是int类型），流变量payPtr指向该文件，则语句应为：

  ```c
  fscanf(payPtr,”%d%d”,&account,&amount); 
  ```

- 小数点的合法写法：小数点两边有一个是零的话可以不用写1.0在C语言中可写成1.       0.1在C语言中可以写成.1 

- 如何实现保留三位小数，第四位四舍五入的程序：y= ( int ) ( x*1000+0.5 )/1000.0; 

- 在给枚举变量赋值时，不能使用整数。例如，下面的代码是不正确的：workday =2;因为它们属于不同的类型，如果进行强制类型转换后就可以进行赋值了，代码如下:workday= (enum weekday)2; 

- C语言中const和#define都能用来定义常量，但const比#define有更多的优点：

  1.const定义的常量是有数据类型的，而利用#define定义的宏常量没有数据类型。编译器可以对前者进行类型安全检查，而后者进行字符替换，没有类型安全检查，并且在替换字符时，可能会发生一些意外的错误。

  2.在一些集成化的调试工具中可以对const定义的常量进行调试，但是不能对宏常量进行调试。 

- 在使用浮点变量时，不能将浮点变量用“==”或“！=”与任何数字比较。因为无论是float还是double类型的变量都是具有精度限制的，所以应该设法转换成“>=”或“<=”的形式。 

- 使用const变量可以避免只读变量被意外修改。另外，大多数编译器不会为const变量分配存储空间，而是将它们保存在符号表中，这样就不需要读写内存的操作。不过const限定的对象通常是运行时不能被赋值的对象，因此用const限定的对象的值并不是一个真正的常量，不能用作数组维度。 

- 需要注意的是，使用malloc函数分配的内存空间是在堆中，而不是在栈中。所以在使用完这块内存后一定要将其释放掉。 

- a++的结果不能作为左值 

- 如果算术运算符的一个操作数是有符号整数，另一个是无符号整数，那么有符号整数会被转换成无符号整数，“溢出”也不可能发生。 

- 用extern声明的变量必须是全局变量，这是因为只有全局变量才具有外部链接。 

- register auto int n=8;（✖）（自动变量不能定义为储存器变量） 

- 全局数组或者静态数组未初始化，其初始值自动设置为0；自动数组未初始化，其初始值是未知的。 

- 全局/静态变量未初始化，系统自动初始化为NULL，此时指向对象不存在；自动指针变量未初始化，保留原来存储在内存空间中数据；此时指针指向的对象没有意义。引用未初始化的指针可能会造成系统崩溃等严重错误，因此指针在使用前必须初始化。 

- main（）结束时会隐式调用exit（）。 

- 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。

  ```c
  #include <stdio.h>
  #define message_for(a, b) printf(#a " and " #b ": We love you!\n")
  int main(void){  
      message_for(Carole, Debra);  
      return 0;
  }
  ```

  当上面的代码被编译和执行时，它会产生下列结果：Carole and Debra: We love you!

- 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。

  ```c
  #include <stdio.h>
  #define tokenpaster(n) printf ("token" #n " = %d", token##n)
  int main(void){  
      int token34 = 40;  
      tokenpaster(34);  
      return 0;
  }
  ```

  当上面的代码被编译和执行时，它会产生下列结果：token34 = 40

- C 语言提供了 **perror()** 和 **strerror()** 函数来显示与 **error** 相关的文本消息。**perror()** 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 error 值的文本表示形式。**strerror()** 函数，返回一个指针，指针指向当前 error 值的文本表示形式。让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 **stderr** 文件流来输出所有的错误。

  ```c
  #include <stdio.h>
  #include <errno.h>
  #include <string.h>
  extern int errno ;
  int main (){  
      FILE * pf;  
      int errnum;  
      pf = fopen ("unexist.txt", "rb");  
      if (pf == NULL)  {     
          errnum = errno;     
          fprintf(stderr, "错误号: %d\n", errno);     
          perror("通过 perror 输出错误");     
          fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));  
      }  else  {     
          fclose (pf);  
      }  
      return 0;
  }
  ```

  当上面的代码被编译和执行时，它会产生下列结果：

  错误号: 2

  通过 perror 输出错误: No such file or directory

  打开文件错误: No such file or directory

- 通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  main(){  
      int dividend = 20;  
      int divisor = 5;  
      int quotient;  
      if( divisor == 0)  {    
          fprintf(stderr, "除数为 0 退出运行...\n");    
          exit(EXIT_FAILURE);  
      }  
      quotient = dividend / divisor;  
      fprintf(stderr, "quotient 变量的值为: %d\n", quotient );
    	exit(EXIT_SUCCESS);
  }
  ```

  当上面的代码被编译和执行时，它会产生下列结果：quotient 变量的值为 : 4