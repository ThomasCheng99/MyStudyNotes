- 操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如_kcab），因此最好避免在自己的程序中使用这种名称。标志标签都以一个或两个下划线字符开始，如库标识符。这样的标识符都是保留的。这意味着，虽然使用它们没有语法错误，但是会导致名称冲突。 
- 对于一些算术运算（如两个很大的数相减），浮点数损失的精度更多。 
- 在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。 
- int类型被认为是计算机处理整数类型时最高效的类型。 
- 注意，用%d显示float类型的值，其值不会被转换成int类型。在不同平台下，缺少参数或参数类型不匹配导致的结果不同。 
- 注意，在C语言中，用const类型限定符声明的变量，不是常量。 
- 实际上，标准规定：无论何种情况，只要a和b都是整数值，便可通过a-(a/b)*b来计算a%b。 
- 递增和递减运算符只能影响一个变量。 
- 实际上，C语言具有通常是汇编语言才具有的微调控制能力（汇编语言是为特殊的中央处理单元设计的一系列内部指令，使用助记符来表示；不同的CPU系统使用不同的汇编语言），可以根据具体情况微调程序以获得最大运行速度或最有效地使用内存。 
- 求模运算符只能用于整数，不能用于浮点数。 
- printf（）函数也有返回值，它返回打印字符的个数。如果有输出错误，printf（）则返回一个负值。注意计算针对所有字符数，包括空格和不可见的换行符（\n）。 
- 序列点是程序执行的点，在该点上，所有副作用都在进入下一步之前发生。在C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。 
- C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。 
- 切记：创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。 
- const double * pc= rates;声明并初始化一个不能修改指向地址上的值的指针 
- double * const pc= rates;声明并初始化一个不能指向别处的指针
- const double * const pc= rates;声明并初始化一个既不能修改它所指向的地址，也不能修改指向地址上的值。 
- 如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。 
- 递增运算符一个优点是，通常它生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越来越智能，这一优势可能会消失。 
- 注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果。 
- 除法运算“/”在使用时要特别注意数据类型。因为两个整数（或字符）执行除法运算时，其结果是整型。两个浮点数相除，结果为浮点数。而两个类型不同的数相除时，先进行类型转换，再运算。例如：5/2的结果为2，而不是2.5。因为5和2都是整型常量，其除法结果也是整型。而表达式5/2.0的结果是2.5，因为其中一个操作数2.0是double类型的，所以整型常量5将被转换为double类型之后，再完成除法运算。 
- 当赋值运算符的左侧对象名称和右侧表达式的数据类型不一致时，按照赋值的类型转换规则进行。赋值运算的类型转化规则非常简单：将赋值右部（表达式）的值转化为赋值左部（赋值目标，对象名称）的类型，再完成赋值操作。例如，假设又如下定义语句int x; float y=3.5;  x=y;    执行时，先将y的值3.5转化为变量x的类型后，再执行赋值操作，所以x的值为3。 
- 假设变量a的初值为2，表达式a+=a-=4  执行时，先计算a-=4，其结果为-2；此时，变量a的值被更改为-2。然后再计算a+=-2，则变量a的值被更改为-4。表达式的结果是-4。 
- 逻辑运算中的“短路原则”：指在完成与运算“&&”和或运算“||”中，如果能够提前得出这个表达式的结果，就不再继续余下的运算。例如，假设int型变量m,n,a,b的初值均为0，那么执行表达式（m=a>b）&&（n=a>=b）时，先计算“（m=a>b）”的值，其值为0。这时可以提前确定整个表达式的值是0，子表达式“（n=a>=b）”不再执行，其中的副作用（更改变量n的取值）不会执行。所以，表达式计算之后，变量n的值仍然是原来的0，而不是1。 
- 强制类型转换运算符优先级别高于除法，所以表达式（float）5/2等价于（float）（5）/2表示将5转换成float，再除以2，结果为2.5。而表达式（float）（5/2）先计算5整除2的结果，再转换成float。表达式结果是2.0。 
- 当使用某些对操作数类型有限制的运算符时，可以用到强制类型转换运算符。例如：int i=3；   float x=13.6；   （int）x%i; 中就必须有（int）运算符，这是因为x不是整型，不能参与模除运算。必须先对x进行类型转换，然后才能执行模除运算。但需要注意的是此时x的值并未发生改变。 
- C语言只有十进制、八进制、十六进制，而没有二进制。但运行的时候，所有的进制都要转化为二进制来进行处理。 
- int x=y=10；（错误，定义时，不可以连续赋值）     int x,y;  x=y=10;（正确，定义后，可以连续赋值） 
- 空语句不可以随意执行，会导致逻辑错误。 
- 注释不是C语言，不占运行时间，没有分号，不能嵌套。