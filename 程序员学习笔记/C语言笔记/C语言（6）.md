- 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x*y++表示的是（x）*（y++），并且递增和递减运算符只能影响一个变量。 
- 声明创建了名称和类型，并为其分配内存位置。注意，声明不是表达式语句。也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值。 
- 比较浮点数时，尽量使用<和>。 
- 关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。这意味着x>y+2和x>（y+2）相同，x=y>2和x=（y>2）相同。换言之，如果y大于2，则把x赋值1，否则赋值0。Y的值不会赋给x。 
- 字符是可以进行算术运算的。例如：‘0’-0=48。（‘0’的ASCII码为48） 
- 大写字母和小写字母转换的方法：‘A’+32=‘a’（相互之间一般是相差32）。 
- 八进制转义字符：‘\141’是合法的，前导的0是不能写的；十六进制转义字符：‘\x6d’是合法的，前导的0不能写，并且x是小写。 



```c++
int k=1;   
while（--k）;       
printf（“%d”,k）;   
结果为0
```



```c++
int k=1;     
while（k--）;       
printf（“%d”,k）;       
结果为-1
```



- 能否把main（）定义为void，以避免扰人的“main无返回值”警告？答：不能。main（）必须声明为返回int，且没有参数或者接受适当类型的两个参数。 
- 注意C语言的关键字都是小写的。例如else是关键字，但ELSE就不是关键字。 
- %运算的符号只取决于第一个运算数的符号。例如：7% 4——结果为3；-7% 4——结果为-3；-7%-4——结果为-3；7%-4——结果为3；0% 5——结果为0。 
- 形参与实参类型一致，个数相同;若形参与实参类型不一致，自动按形参类型转换 ;形参在函数被调用前不占内存;函数调用时为形参分配内存；调用结束，内存释放。 
- 递归函数：每调用函数一次，在内存堆栈区分配空间，用于存放函数变量、返回值等信息，所以递归次数过多，可能引起堆栈溢出。 
- EOF在stdio.h中定义，通常为-1。 
- 使用%p可显示地址，它令printf（）以主机的地址格式显示机器地址。 
- 混合使用getchar（）和scanf（）时，如果在调用getchar（）之前，scanf（）在输入行留下一个换行符，会导致一些问题。 
- 精度说明符作用于整数时，决定必须显示的最小位数，不足时左侧填充0。例如：执行printf（“%3.8d\n”,1000）；之后显示00001000。 
- 默认时，scanf（）遇空白类字符（空格、跳格、回车）停止输入整数。 
- 使用扫描集合：扫描集合是以百分号开始，紧随用方括号括起的一组字符，它仅用于输入字符串。当scanf（）出来扫描集合时，将输入属于扫描集合中定义的组内的字符。这些字符将被赋值给扫描集合对应的变元指向的字符数组中。例如：执行char str1[20],str2[20]; scanf(“%[abcdefg]%s”,str1,str2);运行时从键盘输入abcdtye——由于t不是扫描集合【abcdefg】中定义的字符，scanf（）读到字符t之后，停止向str1输入字符。因此，str1的内容为“abcd”，str2的内容为“tye”。 
- 忽略输入：在域的格式说明符前面加星号（*）时，使得scanf（）读入数据但不将该数据赋值给任何变量。例如：执行int x,y;  scanf(“%d%**c%d”,&x,&y);运行时从键盘输入10，10——逗号可以被读入，但被scanf（）忽略，不保存到任何变量中。因此，变量x、y的值都是10。 
- 格式说明符：%n——%n可令printf（）和scanf（）将已经打印或者读入的字符个数存储到相应的变元指向的整型变量中。%n对应的变元必须是地址（整数指针）。