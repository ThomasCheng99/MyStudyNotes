- 在使用setw（n）时要注意：

  - 1）如一个输出量需要比setw（n）确定的字符数更多的字符，则该输出量将使用它所需要的宽度。
  - 例如：float sum=3.12345;   cout<<setw(4)<<sum<<endl;其运行结果为3.12345 
  - 2）setw（n）仅影响下一个数值输出，使用setw设置的间隔方式并不保留其效力。
  - 例如：Cout<<200<<setw(8)<<400<<600<<endl;其运行结果为：200   400600 

- 一般情况下，实参个数应该与形参个数相同，但C++语言允许实参个数与形参个数不同。方式是在说明函数原型时，为一个或多个形参指定默认值，以后调用此函数时，若省略其中某个实参，C++语言自动地以缺省值作为相应参数的值。例如：

  ```c++
  int Init(int x=5,int y=10);
  Init(100,80);   //x=100,y=80
  Init(25);    //x=25,y=10
  Init(10);    //x=10,y=10
  ```

  说明：

  - 1）在函数原型中，所有取缺省值的参数都必须出现在不缺省值的参数右边，即一旦开始定义取缺省值的参数，就不可以在说明非缺省值的参数。例如：int Fun(int I,int j=5,int k);应该改为：Int Fun(int I,int k,int j=5); 
  - 2）在函数调用时，实际参数提供的顺序应该是从左向右依次提供，实际参数的最少个数应等于不具有默认参数值的形式参数个数。若某个参数省略，则其后的参数皆应省略而采用默认值。不允许某个参数省略后，在给其后的参数指定参数值。例如不允许出现Init(,20); 
  - 3）如果制定了默认参数值的形式参数在调用时又得到了实际参数，则实际参数优先。在调用时如果不提供对应参数，形式参数才使用默认参数值。 

- 在函数说明前冠以关键字inline，该函数就被声明为内联函数。每当程序中出现对该函数的调用时，C++编译器使用函数体中的代码插入到调用该函数的语句之处，在程序运行时不再进行函数调用，这主要是为了消除函数调用时的系统开销，以提高运行速度。 说明：

  - 1）C++语言的内联函数具有与C语言的宏定义相同的作用和相似的机理，但消除了#define的不安全因素。 
  - 2）内联函数体内一般不能有循环语句和开关语句。 
  - 3）使用内联函数是一种用空间换时间的措施，若内联函数较长，且调用太频繁时，程序将加长很多。因此，通常只有较短的函数才定义为内联函数，对于较长的函数最好作为一般函数处理。 

```c++
#include<iostream>
using namespace std;

int Add(int x, int y)
{  
    return x + y;
}

int Add(int x, int y, int z)
{  
    return x + y + z;
}

int main()
{  
    int a = 3, b = 4, c = 5;  
    cout << a << "+" << b << "=" << Add(a, b) << endl;  
    cout << a << "+" << b << "+" << c << "=" << Add(a, b, c) << endl;  
    return 0;
}
```

- 说明：
  - 1）返回类型不在参数匹配检查之列。若两个函数除返回类型不同外，其他均相同，则是非法的。例如：int Mul(int x,int y);    double Mul(int x,int y);虽然这两个函数的返回类型不同，但是由于参数个数和类型完全相同，编译程序将无法区分这两个函数。因为在确定调用哪一个函数之前，返回类型是不知道的。 
  - 2）函数的重载与带默认值的函数一起使用时，有可能引起二义性，例如：Void DrawCircl(int r=0,int x=0,int y=0);Void DrawCircl(int r);调用DrawCircl(20)时，编译器不确定使用哪一个函数。 
  - 3）在函数调用时，如果给出的实参和形参类型不相符，C++语言的编译器会自动做类型转换工作。如果转换成功，则程序继续运行，但在这种情况下，有可能产生不可识别的错误。例如：Void F(int x);Void F(long x);虽然这两个函数满足函数重载的条件，但是如果用int c=F(5.56);去调用，就会出现不可分辨的错误，这是由编译器无法确定将5.56转换成int还是long类型造成的。 
- 说明：
  - 1）在声明一个引用时，如果不是作为函数的参数或返回值类型，就必须对它进行初始化，以明确使用是哪一个变量的别名，以后在程序中不可改变这种别名关系。 
  - 2）引用只是某一个变量的别名，系统不为引用另外分配内存空间，与所代表的变量占用同一内存。 
  - 3）并不是所有类型的数据都可以有引用，不能建立void型引用、引用的引用、指向引用的指针、引用数组。 
- 程序运行时，计算机的内存被分为4个区，即程序代码区、全程数据区、栈和堆，其中堆可由用户分配和释放。 
- new和delete的优点：
  - 1）new可以自动计算所要分配内存的类型的大小，而不必使用sizeof（）来计算所需要的字节数，这就减少了发生错误的可能性。 
  - 2）new能够自动返回正确的指针类型，不必对返回指针进行强制类型转换。 
  - 3）可以用new将分配的对象初始化。 
  - 4）new和delete都可以被重载，运行建立自定义的内存管理算法。 
  - 5）用new分配的空间，使用过结束后应该用也只能用delete显式地释放，否则这部分空间将不能收回而变成死空间。 
  - 6）使用new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针，因此通常要对内存的动态分配是否成功进行检查。 
- C++语言异常处理机制的基本思想是将异常的检测与处理分离。当在一个函数体中检测到异常条件存在，但却无法确定相应的处理方法时，该函数抛出一个异常，由函数的直接或间接调用捕获这个异常并处理这个错误。如果程序始终没有处理这个异常，最终运行系统捕获后，通常只是简单地终止这个程序。